/* 
  1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.
  소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다. (1은 소수가 아닙니다.)
*/

function solution(n) {
  let dap = 0;
  const arr = [];

  arr.length = n;
  arr.fill(0);

  for (let i = 2; i <= n; i++) {
    arr[i] = i;
  }

  for (let i = 2; i <= n; i++) {
    if (arr[i] === 0) continue;

    for (let j = i * 2; j <= n; j += i) {
      if (arr[j] === 0) continue;

      arr[j] = 0;
    }
  }

  arr.forEach((num) => {
    if (num !== 0) {
      dap++;
    }
  });

  return dap;
}

/* 
  지금까지 프로그래머스 문제에서 효율성 테스트 영역은 없었던 것 같은데 간단한 for문을 이용해 구현했더니 계속해서 시간이 초과되어서
  검색하던 중 소수를 찾는 알고리즘인 '에라토스테네스의 체'라는 것을 알게 됐다. 해당 알고리즘의 순서는 아래와 같다.
  
  1. 2부터 N까지의 숫자를 순서대로 나열한다.
  2. 가장 작은 소수인 2의 배수를 모두 소거한다.
  3. 그 다음으로 작은 소수인 3의 배수를 모두 소거한다.
  4. 위의 과정을 계속해서 진행한다. (소수이면 해당 배수를 찾아서 소거하는 규칙)
  5. 그렇게 소거되지 않은(내 코드 기준으로 0이 아닌) 숫자가 2부터 N까지의 소수다. 
*/
